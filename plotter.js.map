{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///plotter.js","webpack:///webpack/bootstrap abec87e45f0aad780621","webpack:///./Plotter.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_objectWithoutProperties","obj","keys","target","i","indexOf","Object","prototype","hasOwnProperty","_classCallCheck","instance","Constructor","TypeError","defineProperty","value","_extends","assign","arguments","length","source","key","_createClass","defineProperties","props","descriptor","enumerable","configurable","writable","protoProps","staticProps","Plotter","el","opts","_this","canvas","document","querySelector","ctx","getContext","Error","debug","actors","editing","dragging","mousedown","offsetX","width","offsetY","height","vOffsetX","vOffsetY","vMaxOffsetX","vMaxOffsetY","scale","minScale","maxScale","vScale","vWidth","vHeight","functions","origin","x","y","centralizeCoord","addEventListener","e","preventDefault","loc","windowToCanvas","clientX","clientY","locNormalized","normalizeX","normalizeY","consoleDebug","prevLoc","dragCallback","dtX","dtY","cursor","runCycle","onDrag","_centerCoord","centerCoord","deltaY","canvasFocus","keyCode","console","apply","_cursor","css","style","state","color","undefined","stepX","stepY","_vScale","save","strokeStyle","lineWidth","startX","startY","text","Math","floor","textY","font","fillStyle","beginPath","moveTo","lineTo","tWidth","measureText","fillText","stroke","_i","_tWidth","_x4","_y","toFixed","ceil","restore","clearRect","bbox","getBoundingClientRect","left","top","x_padding","y_padding","_origin","fx","n","scaledWidth","k","f","Points","Array","Function","error","endX","push","func","opt","index","_this2","forEach","_ref","drawPoints","generatePoints","amountPoints","data","custom","_this3","point","line","pointSize","pointColor","lineColor","fill","_vScale2","xScale","yScale","drawPoint","radius","arc","PI","_ref2","_ref3","clearCanvas","translate","drawGrid","drawAxes","drawFunctions","number","round","get"],"mappings":"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","file":"plotter.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Plotter\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Plotter\"] = factory();\n\telse\n\t\troot[\"Plotter\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Plotter\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Plotter\"] = factory();\n\telse\n\t\troot[\"Plotter\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Plotter = function () {\n\t  function Plotter(el, opts) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, Plotter);\n\t\n\t    var canvas = typeof el === 'string' ? document.querySelector(el) : el;\n\t    this.ctx = canvas.getContext('2d');\n\t\n\t    if (!canvas || !this.ctx) throw new Error({ 'Error': 'Canvas element not found.' });\n\t\n\t    this.debug = false;\n\t    this.actors = [];\n\t    this.editing = true;\n\t    this.dragging = false;\n\t    this.mousedown = {};\n\t    this.offsetX = this.width / 2;\n\t    this.offsetY = this.height / 2;\n\t    this.vOffsetX = 0;\n\t    this.vOffsetY = 0;\n\t    this.vMaxOffsetX = 20;\n\t    this.vMaxOffsetY = 20;\n\t    this.scale = 1;\n\t    this.minScale = 0.4;\n\t    this.maxScale = 4;\n\t    this.vScale = {\n\t      width: 50,\n\t      vWidth: 1,\n\t      height: 50,\n\t      vHeight: 5\n\t    };\n\t\n\t    this.functions = [];\n\t\n\t    this.origin = {\n\t      x: 0,\n\t      y: 0\n\t    };\n\t\n\t    Object.assign(this, opts);\n\t\n\t    this.centralizeCoord(this.origin.x, this.origin.y);\n\t\n\t    canvas.addEventListener('mousedown', function (e) {\n\t      e.preventDefault();\n\t      var loc = _this.windowToCanvas(e.clientX, e.clientY);\n\t      var locNormalized = { x: _this.normalizeX(loc.x), y: _this.normalizeY(loc.y) };\n\t\n\t      _this.consoleDebug('mousedown', loc);\n\t      _this.consoleDebug('mousedown (normalized)', locNormalized);\n\t      _this.consoleDebug('normalize debug | offsetX: ' + _this.offsetX + ' scale: ' + _this.scale);\n\t\n\t      _this.dragging = true;\n\t      _this.prevLoc = loc;\n\t      _this.dragCallback = function (loc) {\n\t        var dtX = (loc.x - this.prevLoc.x) / this.scale;\n\t        var dtY = (loc.y - this.prevLoc.y) / this.scale;\n\t        this.offsetX += dtX;\n\t        this.offsetY += dtY;\n\t        this.prevLoc = loc;\n\t      };\n\t\n\t      _this.cursor('all-scroll');\n\t    });\n\t\n\t    canvas.addEventListener('mousemove', function (e) {\n\t      e.preventDefault(); // prevent selections\n\t      var loc = _this.windowToCanvas(e.clientX, e.clientY);\n\t      if (_this.dragging) {\n\t        _this.cursor('all-scroll');\n\t        _this.dragCallback(loc);\n\t        _this.runCycle();\n\t        if (_this.onDrag) _this.onDrag();\n\t        return;\n\t      }\n\t      _this.cursor('auto');\n\t    });\n\t\n\t    canvas.addEventListener('mouseup', function (e) {\n\t      _this.dragging = false;\n\t      _this.cursor('auto');\n\t    });\n\t\n\t    canvas.addEventListener('mousewheel', function (e) {\n\t      e.preventDefault();\n\t\n\t      var _centerCoord = _this.centerCoord;\n\t      var x = _centerCoord.x;\n\t      var y = _centerCoord.y;\n\t\n\t\n\t      if (e.deltaY > 0 && _this.scale - 0.1 > _this.minScale) {\n\t        _this.scale -= 0.1;\n\t      } else if (e.deltaY < 0 && _this.scale + 0.1 < _this.maxScale) {\n\t        _this.scale += 0.1;\n\t      }\n\t\n\t      _this.centralizeCoord(x, y);\n\t\n\t      _this.runCycle();\n\t    });\n\t\n\t    addEventListener('mousedown', function (e) {\n\t      _this.canvasFocus = e.target == canvas;\n\t    });\n\t\n\t    addEventListener('keydown', function (e) {\n\t      if (!_this.canvasFocus) return;\n\t\n\t      _this.vOffsetX += _this.vOffsetX < _this.vMaxOffsetX ? 1 : 0;\n\t      _this.vOffsetY += _this.vOffsetY < _this.vMaxOffsetY ? 1 : 0;\n\t\n\t      switch (e.keyCode) {\n\t        case 37:\n\t          _this.offsetX += _this.vOffsetX;\n\t          break;\n\t        case 38:\n\t          _this.offsetY += _this.vOffsetY;\n\t          break;\n\t        case 39:\n\t          _this.offsetX -= _this.vOffsetX;\n\t          break;\n\t        case 40:\n\t          _this.offsetY -= _this.vOffsetY;\n\t          break;\n\t      }\n\t\n\t      _this.runCycle();\n\t      if (_this.onDrag) _this.onDrag();\n\t    });\n\t\n\t    addEventListener('keyup', function (e) {\n\t      if (!_this.canvasFocus) return;\n\t      _this.vOffsetX = _this.vOffsetY = 0;\n\t    });\n\t  }\n\t\n\t  _createClass(Plotter, [{\n\t    key: 'consoleDebug',\n\t    value: function consoleDebug() {\n\t      if (this.debug) console.debug.apply(console, arguments);\n\t    }\n\t  }, {\n\t    key: 'cursor',\n\t    value: function cursor(_cursor) {\n\t      var css = this.ctx.canvas.style;\n\t      return _cursor ? css.cursor = _cursor : css.cursor;\n\t    }\n\t  }, {\n\t    key: 'setState',\n\t    value: function setState(state) {\n\t      this.state = state;\n\t    }\n\t  }, {\n\t    key: 'isState',\n\t    value: function isState(state) {\n\t      return this.state === state;\n\t    }\n\t  }, {\n\t    key: 'drawGrid',\n\t    value: function drawGrid() {\n\t      var color = arguments.length <= 0 || arguments[0] === undefined ? 'lightgrey' : arguments[0];\n\t      var stepX = arguments.length <= 1 || arguments[1] === undefined ? 25 : arguments[1];\n\t      var stepY = arguments.length <= 2 || arguments[2] === undefined ? 25 : arguments[2];\n\t      var ctx = this.ctx;\n\t      var _vScale = this.vScale;\n\t      var vWidth = _vScale.vWidth;\n\t      var vHeight = _vScale.vHeight;\n\t\n\t\n\t      ctx.save();\n\t      ctx.strokeStyle = color;\n\t      ctx.lineWidth = 0.5;\n\t\n\t      var width = this.width / this.scale;\n\t      var height = this.height / this.scale;\n\t\n\t      var startX = this.offsetX % stepX;\n\t      var startY = this.offsetY % stepY;\n\t\n\t      var text = -Math.floor((this.offsetX + stepX) / stepX);\n\t      var textY = -Math.floor((this.offsetY + stepY) / stepY);\n\t\n\t      ctx.font = \"10pt Arial\";\n\t      ctx.fillStyle = '#000000';\n\t\n\t      for (var i = startX - stepX + 0.5; i < width + stepX; i += stepX) {\n\t        ctx.beginPath();\n\t        ctx.moveTo(i - this.offsetX, 0 - this.offsetY);\n\t        ctx.lineTo(i - this.offsetX, height - this.offsetY);\n\t\n\t        var tWidth = ctx.measureText(text).width;\n\t        var x = i - this.offsetX - tWidth / 2,\n\t            y = this.origin.y + 15;\n\t        ctx.fillText(text++ * vWidth, x, y);\n\t\n\t        ctx.stroke();\n\t      }\n\t\n\t      for (var _i = startY - stepY + 0.5; _i < height + stepY; _i += stepY) {\n\t        ctx.beginPath();\n\t        ctx.moveTo(0 - this.offsetX, _i - this.offsetY);\n\t        ctx.lineTo(width - this.offsetX, _i - this.offsetY);\n\t\n\t        var _tWidth = ctx.measureText(-text).width;\n\t        var _x4 = this.origin.x - (_tWidth + 15),\n\t            _y = _i - this.offsetY - 20;\n\t        ctx.fillText((- textY++ * vHeight).toFixed(1), _x4, _y);\n\t\n\t        ctx.stroke();\n\t      }\n\t\n\t      this.consoleDebug('start', -Math.floor(this.offsetX / stepX));\n\t      this.consoleDebug('plus ahead', Math.ceil(width / stepX));\n\t\n\t      ctx.restore();\n\t    }\n\t  }, {\n\t    key: 'clearCanvas',\n\t    value: function clearCanvas() {\n\t      this.ctx.clearRect(0, 0, this.width, this.height);\n\t    }\n\t  }, {\n\t    key: 'startDragging',\n\t    value: function startDragging(loc) {\n\t      this.mousedown.x = loc.x;\n\t      this.mousedown.y = loc.y;\n\t    }\n\t  }, {\n\t    key: 'windowToCanvas',\n\t    value: function windowToCanvas(x, y) {\n\t      var canvas = this.ctx.canvas;\n\t      var bbox = canvas.getBoundingClientRect();\n\t\n\t      return {\n\t        x: x - bbox.left * (canvas.width / bbox.width),\n\t        y: y - bbox.top * (canvas.height / bbox.height)\n\t      };\n\t    }\n\t  }, {\n\t    key: 'drawHorizontalLine',\n\t    value: function drawHorizontalLine(y) {\n\t      var ctx = this.ctx;\n\t\n\t      ctx.beginPath();\n\t      ctx.moveTo(0 - this.offsetX, y + 0.5);\n\t      ctx.lineTo(0 - this.offsetX + this.width / this.scale, y + 0.5);\n\t      ctx.stroke();\n\t    }\n\t  }, {\n\t    key: 'drawVerticalLine',\n\t    value: function drawVerticalLine(x) {\n\t      var ctx = this.ctx;\n\t\n\t      ctx.beginPath();\n\t      ctx.moveTo(x + 0.5, 0 - this.offsetY);\n\t      ctx.lineTo(x + 0.5, 0 - this.offsetY + this.height / this.scale);\n\t      ctx.stroke();\n\t    }\n\t  }, {\n\t    key: 'drawAxes',\n\t    value: function drawAxes() {\n\t      var xlabel = arguments.length <= 0 || arguments[0] === undefined ? 'x' : arguments[0];\n\t      var ylabel = arguments.length <= 1 || arguments[1] === undefined ? 'y' : arguments[1];\n\t      var opts = arguments[2];\n\t\n\t      var x_pad = this.x_padding + 0.5,\n\t          y_pad = this.y_padding + 0.5;\n\t\n\t      var ctx = this.ctx;\n\t      var _origin = this.origin;\n\t      var x = _origin.x;\n\t      var y = _origin.y;\n\t\n\t\n\t      ctx.strokeStyle = '#000000';\n\t      ctx.lineWidth = 0.5;\n\t\n\t      ctx.beginPath();\n\t\n\t      ctx.moveTo(-this.offsetX, y / this.scale);\n\t      ctx.lineTo(-this.offsetX + this.width / this.scale, y / this.scale);\n\t      ctx.moveTo(x / this.scale, -this.offsetY);\n\t      ctx.lineTo(x / this.scale, -this.offsetY + this.height / this.scale);\n\t      ctx.stroke();\n\t\n\t      // ctx.font = \"12pt Arial\";\n\t      // ctx.fillStyle = '#000000';\n\t      // ctx.textAlign = \"left\";\n\t      // ctx.textBaseline = \"top\";\n\t      // ctx.fillText(xlabel, this.width + this.x_padding + 15/2, this.y_max + this.y_padding - 10);\n\t      // ctx.fillText(ylabel, this.x_min + 15 + 15/2, this.y_padding - 20 );\n\t    }\n\t  }, {\n\t    key: 'generatePoints',\n\t    value: function generatePoints(fx) {\n\t      var n = arguments.length <= 1 || arguments[1] === undefined ? 100 : arguments[1];\n\t      var vScale = this.vScale;\n\t\n\t      var scaledWidth = this.width / this.scale;\n\t      var k = scaledWidth / vScale.width / n;\n\t      var f = function f() {};\n\t\n\t      var Points = new Array();\n\t\n\t      try {\n\t        f = new Function('x', 'with (Math) return ' + fx);\n\t        f(0);\n\t      } catch (e) {\n\t        console.error('bad expression input');\n\t        return [];\n\t      }\n\t\n\t      var startX = -(Math.floor(this.offsetX / vScale.width) + 1);\n\t      var endX = Math.ceil((scaledWidth - this.offsetX) / vScale.width) + 1;\n\t\n\t      for (var i = startX; i <= endX; i += k) {\n\t        Points.push({ x: i, y: f(i) });\n\t      }\n\t\n\t      return Points;\n\t    }\n\t  }, {\n\t    key: 'centralizeCoord',\n\t    value: function centralizeCoord(x, y) {\n\t      this.offsetX = x + this.width / 2 / this.scale;\n\t      this.offsetY = y + this.height / 2 / this.scale;\n\t      this.runCycle();\n\t    }\n\t  }, {\n\t    key: 'addFunction',\n\t    value: function addFunction(func) {\n\t      var opt = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t      opt.func = func;\n\t\n\t      var index = this.functions.push(_extends({}, opt, { func: func }));\n\t\n\t      this.runCycle();\n\t\n\t      return this.functions[index - 1];\n\t    }\n\t  }, {\n\t    key: 'drawFunctions',\n\t    value: function drawFunctions(n) {\n\t      var _this2 = this;\n\t\n\t      this.functions.forEach(function (_ref) {\n\t        var func = _ref.func;\n\t\n\t        var opt = _objectWithoutProperties(_ref, ['func']);\n\t\n\t        return _this2.drawPoints(_this2.generatePoints(func, opt.amountPoints), opt);\n\t      });\n\t    }\n\t  }, {\n\t    key: 'drawPoints',\n\t    value: function drawPoints(data, custom) {\n\t      var _this3 = this;\n\t\n\t      var opts = {\n\t        color: '#0000ff',\n\t        point: true,\n\t        line: true,\n\t        pointSize: 1,\n\t        lineWidth: 1,\n\t        pointColor: 'black',\n\t        lineColor: 'black',\n\t        fill: true\n\t      };\n\t\n\t      Object.assign(opts, custom);\n\t\n\t      var ctx = this.ctx;\n\t      var origin = this.origin;\n\t      var _vScale2 = this.vScale;\n\t      var vWidth = _vScale2.vWidth;\n\t      var vHeight = _vScale2.vHeight;\n\t\n\t      var xScale = this.vScale.width / vWidth;\n\t      var yScale = this.vScale.height / vHeight;\n\t\n\t      ctx.save();\n\t\n\t      var drawPoint = function drawPoint(x, y, radius) {\n\t        ctx.beginPath();\n\t        ctx.arc(x * xScale, -y * yScale, radius / _this3.scale, 0, 2 * Math.PI, true);\n\t        opts.fill ? ctx.fill() : ctx.stroke();\n\t      };\n\t\n\t      if (opts.line) {\n\t        ctx.beginPath();\n\t        ctx.strokeStyle = opts.lineColor;\n\t        data.forEach(function (_ref2) {\n\t          var x = _ref2.x;\n\t          var y = _ref2.y;\n\t          return ctx.lineTo(x * xScale, -y * yScale);\n\t        });\n\t        ctx.lineWidth = opts.lineWidth;\n\t        ctx.stroke();\n\t      }\n\t\n\t      if (opts.point) {\n\t        ctx.strokeStyle = ctx.fillStyle = opts.pointColor;\n\t        data.forEach(function (_ref3) {\n\t          var x = _ref3.x;\n\t          var y = _ref3.y;\n\t          return drawPoint(x, y, opts.pointSize);\n\t        });\n\t      }\n\t\n\t      ctx.restore();\n\t    }\n\t  }, {\n\t    key: 'runCycle',\n\t    value: function runCycle() {\n\t      var ctx = this.ctx;\n\t      var vScale = this.vScale;\n\t\n\t      this.clearCanvas();\n\t      ctx.save();\n\t      ctx.scale(this.scale, this.scale);\n\t      ctx.translate(this.offsetX, this.offsetY);\n\t      this.drawGrid('lightgray', vScale.width, vScale.height);\n\t      this.drawAxes();\n\t\n\t      this.drawFunctions(100);\n\t\n\t      ctx.restore();\n\t    }\n\t  }, {\n\t    key: 'normalizeX',\n\t    value: function normalizeX(x) {\n\t      return (x - this.offsetX) / this.scale;\n\t    }\n\t  }, {\n\t    key: 'normalizeY',\n\t    value: function normalizeY(y) {\n\t      return (y - this.offsetY) / this.scale;\n\t    }\n\t  }, {\n\t    key: 'round',\n\t    value: function round(number) {\n\t      return +(Math.round(number * 2) / 2).toFixed(1);\n\t    }\n\t  }, {\n\t    key: 'width',\n\t    get: function get() {\n\t      return this.ctx.canvas.width;\n\t    }\n\t  }, {\n\t    key: 'height',\n\t    get: function get() {\n\t      return this.ctx.canvas.height;\n\t    }\n\t  }, {\n\t    key: 'centerCoord',\n\t    get: function get() {\n\t      return {\n\t        x: this.offsetX - this.width / 2 / this.scale,\n\t        y: this.offsetY - this.height / 2 / this.scale\n\t      };\n\t    }\n\t  }]);\n\t\n\t  return Plotter;\n\t}();\n\t\n\texports.default = Plotter;\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** plotter.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap abec87e45f0aad780621\n **/","export default class Plotter {\n  constructor(el, opts) {\n    let canvas = typeof el === 'string' ? document.querySelector(el) : el;\n    this.ctx = canvas.getContext('2d');\n    \n    if (!canvas || !this.ctx)\n      throw new Error({'Error': 'Canvas element not found.'});\n    \n    this.debug = false;\n    this.actors = [];\n    this.editing = true;\n    this.dragging = false;\n    this.mousedown = {};\n    this.offsetX = this.width/2;\n    this.offsetY = this.height/2;\n    this.vOffsetX = 0;\n    this.vOffsetY = 0;\n    this.vMaxOffsetX = 20;\n    this.vMaxOffsetY = 20;\n    this.scale = 1;\n    this.minScale = 0.4;\n    this.maxScale = 4;\n    this.vScale = {\n      width: 50,\n      vWidth: 1,\n      height: 50,\n      vHeight: 5  ,\n    };\n\n    this.functions = [];\n\n    this.origin = {\n      x: 0,\n      y: 0,\n    };\n\n    Object.assign(this, opts);\n\n    this.centralizeCoord(this.origin.x, this.origin.y);\n\n    canvas.addEventListener('mousedown', e => {\n      e.preventDefault();\n      const loc = this.windowToCanvas(e.clientX, e.clientY);\n      const locNormalized = { x: this.normalizeX(loc.x), y: this.normalizeY(loc.y) };\n\n      this.consoleDebug('mousedown', loc);\n      this.consoleDebug('mousedown (normalized)', locNormalized);\n      this.consoleDebug(`normalize debug | offsetX: ${this.offsetX} scale: ${this.scale}`);\n\n      this.dragging = true;\n      this.prevLoc = loc;\n      this.dragCallback = function(loc) {\n        let dtX = (loc.x - this.prevLoc.x)/this.scale;\n        let dtY = (loc.y - this.prevLoc.y)/this.scale;\n        this.offsetX += dtX;\n        this.offsetY += dtY;\n        this.prevLoc = loc;\n      };\n\n      this.cursor('all-scroll');\n    });\n\n    canvas.addEventListener('mousemove', e => {\n      e.preventDefault(); // prevent selections\n      let loc = this.windowToCanvas(e.clientX, e.clientY);\n      if (this.dragging) {\n        this.cursor('all-scroll');\n        this.dragCallback(loc);\n        this.runCycle();\n        if (this.onDrag) this.onDrag();\n        return;\n      }\n      this.cursor('auto');\n\n    });\n\n    canvas.addEventListener('mouseup', e => {\n      this.dragging = false;\n      this.cursor('auto');\n    });\n\n    canvas.addEventListener('mousewheel', e => {\n      e.preventDefault();\n\n      const { x, y } = this.centerCoord;\n\n      if (e.deltaY > 0 && (this.scale - 0.1) > this.minScale) {\n        this.scale -= 0.1;\n      } else if (e.deltaY < 0 && (this.scale + 0.1) < this.maxScale) {\n        this.scale += 0.1;\n      }\n\n      this.centralizeCoord(x, y);\n\n      this.runCycle();\n    });\n\n    addEventListener('mousedown', e =>{\n      this.canvasFocus = e.target == canvas;\n    });\n\n    addEventListener('keydown', e => {\n      if (!this.canvasFocus) return;\n\n      this.vOffsetX += this.vOffsetX < this.vMaxOffsetX ? 1 : 0;\n      this.vOffsetY += this.vOffsetY < this.vMaxOffsetY ? 1 : 0;\n\n      switch (e.keyCode) {\n        case 37:\n          this.offsetX += this.vOffsetX;\n          break;\n        case 38:\n          this.offsetY += this.vOffsetY;\n          break;\n        case 39:\n          this.offsetX -= this.vOffsetX;\n          break;\n        case 40:\n          this.offsetY -= this.vOffsetY;\n          break;\n      }\n\n      this.runCycle();\n      if (this.onDrag) this.onDrag();\n    });\n\n    addEventListener('keyup', e => {\n      if (!this.canvasFocus) return;\n      this.vOffsetX = this.vOffsetY = 0;\n    });\n  }\n\n  get width() {\n    return this.ctx.canvas.width;\n  }\n\n  get height() {\n    return this.ctx.canvas.height;\n  }\n\n  get centerCoord() {\n    return {\n      x: this.offsetX - this.width/2/this.scale,\n      y: this.offsetY - this.height/2/this.scale,\n    };\n  }\n\n  consoleDebug() {\n    if (this.debug)\n      console.debug.apply(console, arguments);\n  }\n\n  cursor(cursor) {\n    let css = this.ctx.canvas.style;\n    return cursor ? css.cursor = cursor : css.cursor;\n  }\n\n  setState(state) {\n    this.state = state;\n  }\n\n  isState(state) {\n    return this.state === state;\n  }\n\n  drawGrid(color = 'lightgrey', stepX = 25, stepY = 25) {\n    const { ctx, vScale: { vWidth, vHeight } } = this;\n\n    ctx.save();\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 0.5;\n\n    const width = this.width/this.scale;\n    const height = this.height/this.scale;\n    \n    const startX = this.offsetX % stepX;\n    const startY = this.offsetY % stepY;\n\n    let text = -Math.floor((this.offsetX + stepX)/stepX);\n    let textY = -Math.floor((this.offsetY + stepY)/stepY);\n    \n    ctx.font = \"10pt Arial\";\n    ctx.fillStyle = '#000000';\n    \n    for (let i = startX - stepX + 0.5; i < width + stepX; i += stepX) {\n      ctx.beginPath();\n      ctx.moveTo(i - this.offsetX, 0 - this.offsetY);\n      ctx.lineTo(i - this.offsetX, height - this.offsetY);\n\n      const tWidth = ctx.measureText(text).width;\n      const x = i - this.offsetX - (tWidth/2), y = this.origin.y + 15;\n      ctx.fillText(text++ * vWidth, x, y);\n\n      ctx.stroke();\n    }\n\n    for (let i = startY - stepY + 0.5; i < height + stepY; i += stepY) {\n      ctx.beginPath();\n      ctx.moveTo(0 - this.offsetX, i - this.offsetY);\n      ctx.lineTo(width - this.offsetX, i - this.offsetY);\n\n      const tWidth = ctx.measureText(-text).width;\n      const x = this.origin.x - (tWidth + 15), y = i - this.offsetY - 20;\n      ctx.fillText((-textY++ * vHeight).toFixed(1), x, y);\n      \n      ctx.stroke();\n    }\n\n    this.consoleDebug('start', -Math.floor(this.offsetX/stepX));\n    this.consoleDebug('plus ahead', Math.ceil(width/stepX));\n\n    ctx.restore();\n  }\n  clearCanvas() {\n    this.ctx.clearRect(0, 0, this.width, this.height);\n  }\n  startDragging(loc) {\n    this.mousedown.x = loc.x;\n    this.mousedown.y = loc.y;\n  }\n  windowToCanvas(x, y) {\n    const canvas = this.ctx.canvas;\n    const bbox = canvas.getBoundingClientRect();\n\n    return { \n      x: x - bbox.left * (canvas.width  / bbox.width),\n      y: y - bbox.top  * (canvas.height / bbox.height),\n    };\n  }\n  drawHorizontalLine (y) {\n    const { ctx } = this;\n    ctx.beginPath();\n    ctx.moveTo(0 - this.offsetX, y+0.5);\n    ctx.lineTo(0 - this.offsetX + this.width/this.scale, y+0.5);\n    ctx.stroke();\n  }\n  drawVerticalLine (x) {\n    const { ctx } = this;\n    ctx.beginPath();\n    ctx.moveTo(x+0.5, 0 - this.offsetY);\n    ctx.lineTo(x+0.5, 0 - this.offsetY + this.height/this.scale);\n    ctx.stroke();\n  }\n  \n  drawAxes(xlabel = 'x', ylabel = 'y', opts) {\n    var x_pad = this.x_padding + 0.5, y_pad = this.y_padding + 0.5;\n\n    const { ctx, origin: { x, y } } = this;\n\n    ctx.strokeStyle = '#000000';\n    ctx.lineWidth = 0.5;\n\n    ctx.beginPath();\n\n\n    ctx.moveTo(-this.offsetX, y/this.scale);\n    ctx.lineTo(-this.offsetX + this.width/this.scale, y/this.scale);\n    ctx.moveTo(x/this.scale, -this.offsetY);\n    ctx.lineTo(x/this.scale, -this.offsetY + this.height/this.scale);\n    ctx.stroke();\n\n    // ctx.font = \"12pt Arial\";\n    // ctx.fillStyle = '#000000';\n    // ctx.textAlign = \"left\";\n    // ctx.textBaseline = \"top\";\n    // ctx.fillText(xlabel, this.width + this.x_padding + 15/2, this.y_max + this.y_padding - 10);\n    // ctx.fillText(ylabel, this.x_min + 15 + 15/2, this.y_padding - 20 );\n\n  }\n\n  generatePoints(fx, n = 100) {\n    const { vScale } = this;\n    const scaledWidth = this.width/this.scale;\n    const k = scaledWidth/vScale.width/n;\n    let f = () => {};\n\n    const Points = new Array();\n\n    try {\n      f = new Function('x', `with (Math) return ${fx}`);\n      f(0);\n    } catch(e) {\n      console.error('bad expression input');\n      return [];\n    }\n\n    const startX = -(Math.floor(this.offsetX/vScale.width) + 1);\n    const endX = Math.ceil((scaledWidth - this.offsetX)/vScale.width) + 1;\n\n    for (let i = startX; i <= endX; i += k) {\n      Points.push({ x: i, y: f(i) });\n    }\n\n    return Points;\n  }\n\n  centralizeCoord(x, y) {\n    this.offsetX = x + this.width/2/this.scale;\n    this.offsetY = y + this.height/2/this.scale;\n    this.runCycle();\n  }\n\n  addFunction(func, opt = {}) {\n    opt.func = func;\n\n    const index = this.functions.push({ ...opt, func });\n\n    this.runCycle();\n\n    return this.functions[index - 1];\n  }\n\n  drawFunctions(n) {\n    this.functions.forEach(({ func, ...opt }) => this.drawPoints(this.generatePoints(func, opt.amountPoints), opt));\n  }\n\n  drawPoints(data, custom) {\n    let opts = {\n      color: '#0000ff',\n      point: true,\n      line: true,\n      pointSize: 1,\n      lineWidth: 1,\n      pointColor: 'black',\n      lineColor: 'black',\n      fill: true,\n    };\n\n    Object.assign(opts, custom);\n    \n    const { ctx, origin, vScale: { vWidth, vHeight } } = this;\n    const xScale = this.vScale.width/vWidth;\n    const yScale = this.vScale.height/vHeight;\n\n    ctx.save();\n\n    const drawPoint = (x, y, radius) => {\n      ctx.beginPath();\n      ctx.arc(x * xScale, -y * yScale, radius/this.scale, 0, 2 * Math.PI, true);\n      opts.fill ? ctx.fill() : ctx.stroke();\n    };\n\n    if (opts.line) {\n      ctx.beginPath();\n      ctx.strokeStyle = opts.lineColor;\n      data.forEach(({ x, y }) => ctx.lineTo(x * xScale,  -y * yScale));\n      ctx.lineWidth = opts.lineWidth;\n      ctx.stroke();\n    }\n\n    if (opts.point) {\n      ctx.strokeStyle = ctx.fillStyle = opts.pointColor;\n      data.forEach(({ x, y }) => drawPoint(x, y, opts.pointSize));\n    }\n\n    ctx.restore();\n  }\n\n  runCycle() {\n    const { ctx, vScale } = this;\n    this.clearCanvas();\n    ctx.save();\n    ctx.scale(this.scale, this.scale);\n    ctx.translate(this.offsetX, this.offsetY);\n    this.drawGrid('lightgray', vScale.width, vScale.height);\n    this.drawAxes();\n\n    this.drawFunctions(100);\n\n    ctx.restore();\n  }\n\n  normalizeX(x) {\n    return (x - this.offsetX)/this.scale;\n  }\n\n  normalizeY(y) {\n    return (y - this.offsetY)/this.scale;\n  }\n\n  round(number) {\n    return +(Math.round(number * 2) / 2).toFixed(1)\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./Plotter.js\n **/"],"sourceRoot":""}