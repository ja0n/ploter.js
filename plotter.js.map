{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///plotter.js","webpack:///webpack/bootstrap 412f33d8e449e612d036","webpack:///./Plotter.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_objectWithoutProperties","obj","keys","target","i","indexOf","Object","prototype","hasOwnProperty","_classCallCheck","instance","Constructor","TypeError","defineProperty","value","_extends","assign","arguments","length","source","key","_createClass","defineProperties","props","descriptor","enumerable","configurable","writable","protoProps","staticProps","Plotter","el","opts","_this","canvas","document","querySelector","ctx","getContext","Error","debug","actors","bgColor","editing","dragging","mousedown","offsetX","width","offsetY","height","vOffsetX","vOffsetY","vMaxOffsetX","vMaxOffsetY","scale","minScale","maxScale","vScale","vWidth","vHeight","functions","origin","x","y","centralizeCoord","addEventListener","e","preventDefault","loc","windowToCanvas","clientX","clientY","locNormalized","normalizeX","normalizeY","consoleDebug","prevLoc","dragCallback","dtX","dtY","cursor","runCycle","onDrag","_centerCoord","centerCoord","deltaY","canvasFocus","keyCode","console","apply","_cursor","css","style","state","color","undefined","stepX","stepY","_vScale","save","strokeStyle","lineWidth","startX","startY","text","Math","floor","textY","font","fillStyle","beginPath","moveTo","lineTo","tWidth","measureText","fillText","stroke","_i","_tWidth","_x4","_y","toFixed","ceil","restore","fillRect","bbox","getBoundingClientRect","left","top","x_padding","y_padding","_origin","fx","n","scaledWidth","k","f","Points","Array","Function","error","endX","push","func","opt","index","_this2","forEach","_ref","drawPoints","generatePoints","amountPoints","data","custom","_this3","point","line","pointSize","pointColor","lineColor","fill","_vScale2","xScale","yScale","drawPoint","radius","arc","PI","_ref2","_ref3","clearCanvas","translate","drawGrid","drawAxes","drawFunctions","number","round","get"],"mappings":"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","file":"plotter.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Plotter\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Plotter\"] = factory();\n\telse\n\t\troot[\"Plotter\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Plotter\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Plotter\"] = factory();\n\telse\n\t\troot[\"Plotter\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Plotter = function () {\n\t  function Plotter(el, opts) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, Plotter);\n\t\n\t    var canvas = typeof el === 'string' ? document.querySelector(el) : el;\n\t    this.ctx = canvas.getContext('2d');\n\t\n\t    if (!canvas || !this.ctx) throw new Error({ 'Error': 'Canvas element not found.' });\n\t\n\t    this.debug = false;\n\t    this.actors = [];\n\t    this.bgColor = '#F5F5F5';\n\t    this.editing = true;\n\t    this.dragging = false;\n\t    this.mousedown = {};\n\t    this.offsetX = this.width / 2;\n\t    this.offsetY = this.height / 2;\n\t    this.vOffsetX = 0;\n\t    this.vOffsetY = 0;\n\t    this.vMaxOffsetX = 20;\n\t    this.vMaxOffsetY = 20;\n\t    this.scale = 1;\n\t    this.minScale = 0.4;\n\t    this.maxScale = 4;\n\t    this.vScale = {\n\t      width: 50,\n\t      vWidth: 1,\n\t      height: 50,\n\t      vHeight: 5\n\t    };\n\t\n\t    this.functions = [];\n\t\n\t    this.origin = {\n\t      x: 0,\n\t      y: 0\n\t    };\n\t\n\t    Object.assign(this, opts);\n\t\n\t    this.centralizeCoord(this.origin.x, this.origin.y);\n\t\n\t    canvas.addEventListener('mousedown', function (e) {\n\t      e.preventDefault();\n\t      var loc = _this.windowToCanvas(e.clientX, e.clientY);\n\t      var locNormalized = { x: _this.normalizeX(loc.x), y: _this.normalizeY(loc.y) };\n\t\n\t      _this.consoleDebug('mousedown', loc);\n\t      _this.consoleDebug('mousedown (normalized)', locNormalized);\n\t      _this.consoleDebug('normalize debug | offsetX: ' + _this.offsetX + ' scale: ' + _this.scale);\n\t\n\t      _this.dragging = true;\n\t      _this.prevLoc = loc;\n\t      _this.dragCallback = function (loc) {\n\t        var dtX = (loc.x - this.prevLoc.x) / this.scale;\n\t        var dtY = (loc.y - this.prevLoc.y) / this.scale;\n\t        this.offsetX += dtX;\n\t        this.offsetY += dtY;\n\t        this.prevLoc = loc;\n\t      };\n\t\n\t      _this.cursor('all-scroll');\n\t    });\n\t\n\t    canvas.addEventListener('mousemove', function (e) {\n\t      e.preventDefault(); // prevent selections\n\t      var loc = _this.windowToCanvas(e.clientX, e.clientY);\n\t      if (_this.dragging) {\n\t        _this.cursor('all-scroll');\n\t        _this.dragCallback(loc);\n\t        _this.runCycle();\n\t        if (_this.onDrag) _this.onDrag();\n\t        return;\n\t      }\n\t      _this.cursor('auto');\n\t    });\n\t\n\t    canvas.addEventListener('mouseup', function (e) {\n\t      _this.dragging = false;\n\t      _this.cursor('auto');\n\t    });\n\t\n\t    canvas.addEventListener('mousewheel', function (e) {\n\t      e.preventDefault();\n\t\n\t      var _centerCoord = _this.centerCoord;\n\t      var x = _centerCoord.x;\n\t      var y = _centerCoord.y;\n\t\n\t\n\t      if (e.deltaY > 0 && _this.scale - 0.1 > _this.minScale) {\n\t        _this.scale -= 0.1;\n\t      } else if (e.deltaY < 0 && _this.scale + 0.1 < _this.maxScale) {\n\t        _this.scale += 0.1;\n\t      }\n\t\n\t      _this.centralizeCoord(x, y);\n\t\n\t      _this.runCycle();\n\t    });\n\t\n\t    addEventListener('mousedown', function (e) {\n\t      _this.canvasFocus = e.target == canvas;\n\t    });\n\t\n\t    addEventListener('keydown', function (e) {\n\t      if (!_this.canvasFocus) return;\n\t\n\t      _this.vOffsetX += _this.vOffsetX < _this.vMaxOffsetX ? 1 : 0;\n\t      _this.vOffsetY += _this.vOffsetY < _this.vMaxOffsetY ? 1 : 0;\n\t\n\t      switch (e.keyCode) {\n\t        case 37:\n\t          _this.offsetX += _this.vOffsetX;\n\t          break;\n\t        case 38:\n\t          _this.offsetY += _this.vOffsetY;\n\t          break;\n\t        case 39:\n\t          _this.offsetX -= _this.vOffsetX;\n\t          break;\n\t        case 40:\n\t          _this.offsetY -= _this.vOffsetY;\n\t          break;\n\t      }\n\t\n\t      _this.runCycle();\n\t      if (_this.onDrag) _this.onDrag();\n\t    });\n\t\n\t    addEventListener('keyup', function (e) {\n\t      if (!_this.canvasFocus) return;\n\t      _this.vOffsetX = _this.vOffsetY = 0;\n\t    });\n\t  }\n\t\n\t  _createClass(Plotter, [{\n\t    key: 'consoleDebug',\n\t    value: function consoleDebug() {\n\t      if (this.debug) console.debug.apply(console, arguments);\n\t    }\n\t  }, {\n\t    key: 'cursor',\n\t    value: function cursor(_cursor) {\n\t      var css = this.ctx.canvas.style;\n\t      return _cursor ? css.cursor = _cursor : css.cursor;\n\t    }\n\t  }, {\n\t    key: 'setState',\n\t    value: function setState(state) {\n\t      this.state = state;\n\t    }\n\t  }, {\n\t    key: 'isState',\n\t    value: function isState(state) {\n\t      return this.state === state;\n\t    }\n\t  }, {\n\t    key: 'drawGrid',\n\t    value: function drawGrid() {\n\t      var color = arguments.length <= 0 || arguments[0] === undefined ? 'lightgrey' : arguments[0];\n\t      var stepX = arguments.length <= 1 || arguments[1] === undefined ? 25 : arguments[1];\n\t      var stepY = arguments.length <= 2 || arguments[2] === undefined ? 25 : arguments[2];\n\t      var ctx = this.ctx;\n\t      var _vScale = this.vScale;\n\t      var vWidth = _vScale.vWidth;\n\t      var vHeight = _vScale.vHeight;\n\t\n\t\n\t      ctx.save();\n\t      ctx.strokeStyle = color;\n\t      ctx.lineWidth = 0.5;\n\t\n\t      var width = this.width / this.scale;\n\t      var height = this.height / this.scale;\n\t\n\t      var startX = this.offsetX % stepX;\n\t      var startY = this.offsetY % stepY;\n\t\n\t      var text = -Math.floor((this.offsetX + stepX) / stepX);\n\t      var textY = -Math.floor((this.offsetY + stepY) / stepY);\n\t\n\t      ctx.font = \"10pt Arial\";\n\t      ctx.fillStyle = '#000000';\n\t\n\t      for (var i = startX - stepX + 0.5; i < width + stepX; i += stepX) {\n\t        ctx.beginPath();\n\t        ctx.moveTo(i - this.offsetX, 0 - this.offsetY);\n\t        ctx.lineTo(i - this.offsetX, height - this.offsetY);\n\t\n\t        var tWidth = ctx.measureText(text).width;\n\t        var x = i - this.offsetX - tWidth / 2,\n\t            y = this.origin.y + 15;\n\t        ctx.fillText(text++ * vWidth, x, y);\n\t\n\t        ctx.stroke();\n\t      }\n\t\n\t      for (var _i = startY - stepY + 0.5; _i < height + stepY; _i += stepY) {\n\t        ctx.beginPath();\n\t        ctx.moveTo(0 - this.offsetX, _i - this.offsetY);\n\t        ctx.lineTo(width - this.offsetX, _i - this.offsetY);\n\t\n\t        var _tWidth = ctx.measureText(-text).width;\n\t        var _x4 = this.origin.x - (_tWidth + 15),\n\t            _y = _i - this.offsetY - 20;\n\t        ctx.fillText((- textY++ * vHeight).toFixed(1), _x4, _y);\n\t\n\t        ctx.stroke();\n\t      }\n\t\n\t      this.consoleDebug('start', -Math.floor(this.offsetX / stepX));\n\t      this.consoleDebug('plus ahead', Math.ceil(width / stepX));\n\t\n\t      ctx.restore();\n\t    }\n\t  }, {\n\t    key: 'clearCanvas',\n\t    value: function clearCanvas() {\n\t      var ctx = this.ctx;\n\t\n\t      ctx.save();\n\t      ctx.fillStyle = this.bgColor;\n\t      ctx.fillRect(0, 0, this.width, this.height);\n\t      ctx.restore();\n\t    }\n\t  }, {\n\t    key: 'startDragging',\n\t    value: function startDragging(loc) {\n\t      this.mousedown.x = loc.x;\n\t      this.mousedown.y = loc.y;\n\t    }\n\t  }, {\n\t    key: 'windowToCanvas',\n\t    value: function windowToCanvas(x, y) {\n\t      var canvas = this.ctx.canvas;\n\t      var bbox = canvas.getBoundingClientRect();\n\t\n\t      return {\n\t        x: x - bbox.left * (canvas.width / bbox.width),\n\t        y: y - bbox.top * (canvas.height / bbox.height)\n\t      };\n\t    }\n\t  }, {\n\t    key: 'drawHorizontalLine',\n\t    value: function drawHorizontalLine(y) {\n\t      var ctx = this.ctx;\n\t\n\t      ctx.beginPath();\n\t      ctx.moveTo(0 - this.offsetX, y + 0.5);\n\t      ctx.lineTo(0 - this.offsetX + this.width / this.scale, y + 0.5);\n\t      ctx.stroke();\n\t    }\n\t  }, {\n\t    key: 'drawVerticalLine',\n\t    value: function drawVerticalLine(x) {\n\t      var ctx = this.ctx;\n\t\n\t      ctx.beginPath();\n\t      ctx.moveTo(x + 0.5, 0 - this.offsetY);\n\t      ctx.lineTo(x + 0.5, 0 - this.offsetY + this.height / this.scale);\n\t      ctx.stroke();\n\t    }\n\t  }, {\n\t    key: 'drawAxes',\n\t    value: function drawAxes() {\n\t      var xlabel = arguments.length <= 0 || arguments[0] === undefined ? 'x' : arguments[0];\n\t      var ylabel = arguments.length <= 1 || arguments[1] === undefined ? 'y' : arguments[1];\n\t      var opts = arguments[2];\n\t\n\t      var x_pad = this.x_padding + 0.5,\n\t          y_pad = this.y_padding + 0.5;\n\t\n\t      var ctx = this.ctx;\n\t      var _origin = this.origin;\n\t      var x = _origin.x;\n\t      var y = _origin.y;\n\t\n\t\n\t      ctx.strokeStyle = '#000000';\n\t      ctx.lineWidth = 0.5;\n\t\n\t      ctx.beginPath();\n\t\n\t      ctx.moveTo(-this.offsetX, y / this.scale);\n\t      ctx.lineTo(-this.offsetX + this.width / this.scale, y / this.scale);\n\t      ctx.moveTo(x / this.scale, -this.offsetY);\n\t      ctx.lineTo(x / this.scale, -this.offsetY + this.height / this.scale);\n\t      ctx.stroke();\n\t\n\t      // ctx.font = \"12pt Arial\";\n\t      // ctx.fillStyle = '#000000';\n\t      // ctx.textAlign = \"left\";\n\t      // ctx.textBaseline = \"top\";\n\t      // ctx.fillText(xlabel, this.width + this.x_padding + 15/2, this.y_max + this.y_padding - 10);\n\t      // ctx.fillText(ylabel, this.x_min + 15 + 15/2, this.y_padding - 20 );\n\t    }\n\t  }, {\n\t    key: 'generatePoints',\n\t    value: function generatePoints(fx) {\n\t      var n = arguments.length <= 1 || arguments[1] === undefined ? 100 : arguments[1];\n\t      var vScale = this.vScale;\n\t\n\t      var scaledWidth = this.width / this.scale;\n\t      var k = scaledWidth / vScale.width / n;\n\t      var f = function f() {};\n\t\n\t      var Points = new Array();\n\t\n\t      try {\n\t        f = new Function('x', 'with (Math) return ' + fx);\n\t        f(0);\n\t      } catch (e) {\n\t        console.error('bad expression input');\n\t        return [];\n\t      }\n\t\n\t      var startX = -(Math.floor(this.offsetX / vScale.width) + 1);\n\t      var endX = Math.ceil((scaledWidth - this.offsetX) / vScale.width) + 1;\n\t\n\t      for (var i = startX; i <= endX; i += k) {\n\t        Points.push({ x: i, y: f(i) });\n\t      }\n\t\n\t      return Points;\n\t    }\n\t  }, {\n\t    key: 'centralizeCoord',\n\t    value: function centralizeCoord(x, y) {\n\t      this.offsetX = x + this.width / 2 / this.scale;\n\t      this.offsetY = y + this.height / 2 / this.scale;\n\t      this.runCycle();\n\t    }\n\t  }, {\n\t    key: 'addFunction',\n\t    value: function addFunction(func) {\n\t      var opt = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t      opt.func = func;\n\t\n\t      var index = this.functions.push(_extends({}, opt, { func: func }));\n\t\n\t      this.runCycle();\n\t\n\t      return this.functions[index - 1];\n\t    }\n\t  }, {\n\t    key: 'drawFunctions',\n\t    value: function drawFunctions(n) {\n\t      var _this2 = this;\n\t\n\t      this.functions.forEach(function (_ref) {\n\t        var func = _ref.func;\n\t\n\t        var opt = _objectWithoutProperties(_ref, ['func']);\n\t\n\t        return _this2.drawPoints(_this2.generatePoints(func, opt.amountPoints), opt);\n\t      });\n\t    }\n\t  }, {\n\t    key: 'drawPoints',\n\t    value: function drawPoints(data, custom) {\n\t      var _this3 = this;\n\t\n\t      var opts = {\n\t        color: '#0000ff',\n\t        point: true,\n\t        line: true,\n\t        pointSize: 1,\n\t        lineWidth: 1,\n\t        pointColor: 'black',\n\t        lineColor: 'black',\n\t        fill: true\n\t      };\n\t\n\t      Object.assign(opts, custom);\n\t\n\t      var ctx = this.ctx;\n\t      var origin = this.origin;\n\t      var _vScale2 = this.vScale;\n\t      var vWidth = _vScale2.vWidth;\n\t      var vHeight = _vScale2.vHeight;\n\t\n\t      var xScale = this.vScale.width / vWidth;\n\t      var yScale = this.vScale.height / vHeight;\n\t\n\t      ctx.save();\n\t\n\t      var drawPoint = function drawPoint(x, y, radius) {\n\t        ctx.beginPath();\n\t        ctx.arc(x * xScale, -y * yScale, radius / _this3.scale, 0, 2 * Math.PI, true);\n\t        opts.fill ? ctx.fill() : ctx.stroke();\n\t      };\n\t\n\t      if (opts.line) {\n\t        ctx.beginPath();\n\t        ctx.strokeStyle = opts.lineColor;\n\t        data.forEach(function (_ref2) {\n\t          var x = _ref2.x;\n\t          var y = _ref2.y;\n\t          return ctx.lineTo(x * xScale, -y * yScale);\n\t        });\n\t        ctx.lineWidth = opts.lineWidth;\n\t        ctx.stroke();\n\t      }\n\t\n\t      if (opts.point) {\n\t        ctx.strokeStyle = ctx.fillStyle = opts.pointColor;\n\t        data.forEach(function (_ref3) {\n\t          var x = _ref3.x;\n\t          var y = _ref3.y;\n\t          return drawPoint(x, y, opts.pointSize);\n\t        });\n\t      }\n\t\n\t      ctx.restore();\n\t    }\n\t  }, {\n\t    key: 'runCycle',\n\t    value: function runCycle() {\n\t      var ctx = this.ctx;\n\t      var vScale = this.vScale;\n\t\n\t      this.clearCanvas();\n\t      ctx.save();\n\t      ctx.scale(this.scale, this.scale);\n\t      ctx.translate(this.offsetX, this.offsetY);\n\t      this.drawGrid('lightgray', vScale.width, vScale.height);\n\t      this.drawAxes();\n\t\n\t      this.drawFunctions(100);\n\t\n\t      ctx.restore();\n\t    }\n\t  }, {\n\t    key: 'normalizeX',\n\t    value: function normalizeX(x) {\n\t      return (x - this.offsetX) / this.scale;\n\t    }\n\t  }, {\n\t    key: 'normalizeY',\n\t    value: function normalizeY(y) {\n\t      return (y - this.offsetY) / this.scale;\n\t    }\n\t  }, {\n\t    key: 'round',\n\t    value: function round(number) {\n\t      return +(Math.round(number * 2) / 2).toFixed(1);\n\t    }\n\t  }, {\n\t    key: 'width',\n\t    get: function get() {\n\t      return this.ctx.canvas.width;\n\t    }\n\t  }, {\n\t    key: 'height',\n\t    get: function get() {\n\t      return this.ctx.canvas.height;\n\t    }\n\t  }, {\n\t    key: 'centerCoord',\n\t    get: function get() {\n\t      return {\n\t        x: this.offsetX - this.width / 2 / this.scale,\n\t        y: this.offsetY - this.height / 2 / this.scale\n\t      };\n\t    }\n\t  }]);\n\t\n\t  return Plotter;\n\t}();\n\t\n\texports.default = Plotter;\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** plotter.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 412f33d8e449e612d036\n **/","export default class Plotter {\n  constructor(el, opts) {\n    let canvas = typeof el === 'string' ? document.querySelector(el) : el;\n    this.ctx = canvas.getContext('2d');\n    \n    if (!canvas || !this.ctx)\n      throw new Error({'Error': 'Canvas element not found.'});\n    \n    this.debug = false;\n    this.actors = [];\n    this.bgColor = '#F5F5F5';\n    this.editing = true;\n    this.dragging = false;\n    this.mousedown = {};\n    this.offsetX = this.width/2;\n    this.offsetY = this.height/2;\n    this.vOffsetX = 0;\n    this.vOffsetY = 0;\n    this.vMaxOffsetX = 20;\n    this.vMaxOffsetY = 20;\n    this.scale = 1;\n    this.minScale = 0.4;\n    this.maxScale = 4;\n    this.vScale = {\n      width: 50,\n      vWidth: 1,\n      height: 50,\n      vHeight: 5  ,\n    };\n\n    this.functions = [];\n\n    this.origin = {\n      x: 0,\n      y: 0,\n    };\n\n    Object.assign(this, opts);\n\n    this.centralizeCoord(this.origin.x, this.origin.y);\n\n    canvas.addEventListener('mousedown', e => {\n      e.preventDefault();\n      const loc = this.windowToCanvas(e.clientX, e.clientY);\n      const locNormalized = { x: this.normalizeX(loc.x), y: this.normalizeY(loc.y) };\n\n      this.consoleDebug('mousedown', loc);\n      this.consoleDebug('mousedown (normalized)', locNormalized);\n      this.consoleDebug(`normalize debug | offsetX: ${this.offsetX} scale: ${this.scale}`);\n\n      this.dragging = true;\n      this.prevLoc = loc;\n      this.dragCallback = function(loc) {\n        let dtX = (loc.x - this.prevLoc.x)/this.scale;\n        let dtY = (loc.y - this.prevLoc.y)/this.scale;\n        this.offsetX += dtX;\n        this.offsetY += dtY;\n        this.prevLoc = loc;\n      };\n\n      this.cursor('all-scroll');\n    });\n\n    canvas.addEventListener('mousemove', e => {\n      e.preventDefault(); // prevent selections\n      let loc = this.windowToCanvas(e.clientX, e.clientY);\n      if (this.dragging) {\n        this.cursor('all-scroll');\n        this.dragCallback(loc);\n        this.runCycle();\n        if (this.onDrag) this.onDrag();\n        return;\n      }\n      this.cursor('auto');\n\n    });\n\n    canvas.addEventListener('mouseup', e => {\n      this.dragging = false;\n      this.cursor('auto');\n    });\n\n    canvas.addEventListener('mousewheel', e => {\n      e.preventDefault();\n\n      const { x, y } = this.centerCoord;\n\n      if (e.deltaY > 0 && (this.scale - 0.1) > this.minScale) {\n        this.scale -= 0.1;\n      } else if (e.deltaY < 0 && (this.scale + 0.1) < this.maxScale) {\n        this.scale += 0.1;\n      }\n\n      this.centralizeCoord(x, y);\n\n      this.runCycle();\n    });\n\n    addEventListener('mousedown', e =>{\n      this.canvasFocus = e.target == canvas;\n    });\n\n    addEventListener('keydown', e => {\n      if (!this.canvasFocus) return;\n\n      this.vOffsetX += this.vOffsetX < this.vMaxOffsetX ? 1 : 0;\n      this.vOffsetY += this.vOffsetY < this.vMaxOffsetY ? 1 : 0;\n\n      switch (e.keyCode) {\n        case 37:\n          this.offsetX += this.vOffsetX;\n          break;\n        case 38:\n          this.offsetY += this.vOffsetY;\n          break;\n        case 39:\n          this.offsetX -= this.vOffsetX;\n          break;\n        case 40:\n          this.offsetY -= this.vOffsetY;\n          break;\n      }\n\n      this.runCycle();\n      if (this.onDrag) this.onDrag();\n    });\n\n    addEventListener('keyup', e => {\n      if (!this.canvasFocus) return;\n      this.vOffsetX = this.vOffsetY = 0;\n    });\n  }\n\n  get width() {\n    return this.ctx.canvas.width;\n  }\n\n  get height() {\n    return this.ctx.canvas.height;\n  }\n\n  get centerCoord() {\n    return {\n      x: this.offsetX - this.width/2/this.scale,\n      y: this.offsetY - this.height/2/this.scale,\n    };\n  }\n\n  consoleDebug() {\n    if (this.debug)\n      console.debug.apply(console, arguments);\n  }\n\n  cursor(cursor) {\n    let css = this.ctx.canvas.style;\n    return cursor ? css.cursor = cursor : css.cursor;\n  }\n\n  setState(state) {\n    this.state = state;\n  }\n\n  isState(state) {\n    return this.state === state;\n  }\n\n  drawGrid(color = 'lightgrey', stepX = 25, stepY = 25) {\n    const { ctx, vScale: { vWidth, vHeight } } = this;\n\n    ctx.save();\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 0.5;\n\n    const width = this.width/this.scale;\n    const height = this.height/this.scale;\n    \n    const startX = this.offsetX % stepX;\n    const startY = this.offsetY % stepY;\n\n    let text = -Math.floor((this.offsetX + stepX)/stepX);\n    let textY = -Math.floor((this.offsetY + stepY)/stepY);\n    \n    ctx.font = \"10pt Arial\";\n    ctx.fillStyle = '#000000';\n    \n    for (let i = startX - stepX + 0.5; i < width + stepX; i += stepX) {\n      ctx.beginPath();\n      ctx.moveTo(i - this.offsetX, 0 - this.offsetY);\n      ctx.lineTo(i - this.offsetX, height - this.offsetY);\n\n      const tWidth = ctx.measureText(text).width;\n      const x = i - this.offsetX - (tWidth/2), y = this.origin.y + 15;\n      ctx.fillText(text++ * vWidth, x, y);\n\n      ctx.stroke();\n    }\n\n    for (let i = startY - stepY + 0.5; i < height + stepY; i += stepY) {\n      ctx.beginPath();\n      ctx.moveTo(0 - this.offsetX, i - this.offsetY);\n      ctx.lineTo(width - this.offsetX, i - this.offsetY);\n\n      const tWidth = ctx.measureText(-text).width;\n      const x = this.origin.x - (tWidth + 15), y = i - this.offsetY - 20;\n      ctx.fillText((-textY++ * vHeight).toFixed(1), x, y);\n      \n      ctx.stroke();\n    }\n\n    this.consoleDebug('start', -Math.floor(this.offsetX/stepX));\n    this.consoleDebug('plus ahead', Math.ceil(width/stepX));\n\n    ctx.restore();\n  }\n  clearCanvas() {\n    const { ctx } = this;\n    ctx.save();\n    ctx.fillStyle = this.bgColor;\n    ctx.fillRect(0, 0, this.width, this.height);\n    ctx.restore();\n  }\n\n  startDragging(loc) {\n    this.mousedown.x = loc.x;\n    this.mousedown.y = loc.y;\n  }\n\n  windowToCanvas(x, y) {\n    const canvas = this.ctx.canvas;\n    const bbox = canvas.getBoundingClientRect();\n\n    return { \n      x: x - bbox.left * (canvas.width  / bbox.width),\n      y: y - bbox.top  * (canvas.height / bbox.height),\n    };\n  }\n\n  drawHorizontalLine (y) {\n    const { ctx } = this;\n    ctx.beginPath();\n    ctx.moveTo(0 - this.offsetX, y+0.5);\n    ctx.lineTo(0 - this.offsetX + this.width/this.scale, y+0.5);\n    ctx.stroke();\n  }\n\n  drawVerticalLine (x) {\n    const { ctx } = this;\n    ctx.beginPath();\n    ctx.moveTo(x+0.5, 0 - this.offsetY);\n    ctx.lineTo(x+0.5, 0 - this.offsetY + this.height/this.scale);\n    ctx.stroke();\n  }\n  \n  drawAxes(xlabel = 'x', ylabel = 'y', opts) {\n    var x_pad = this.x_padding + 0.5, y_pad = this.y_padding + 0.5;\n\n    const { ctx, origin: { x, y } } = this;\n\n    ctx.strokeStyle = '#000000';\n    ctx.lineWidth = 0.5;\n\n    ctx.beginPath();\n\n\n    ctx.moveTo(-this.offsetX, y/this.scale);\n    ctx.lineTo(-this.offsetX + this.width/this.scale, y/this.scale);\n    ctx.moveTo(x/this.scale, -this.offsetY);\n    ctx.lineTo(x/this.scale, -this.offsetY + this.height/this.scale);\n    ctx.stroke();\n\n    // ctx.font = \"12pt Arial\";\n    // ctx.fillStyle = '#000000';\n    // ctx.textAlign = \"left\";\n    // ctx.textBaseline = \"top\";\n    // ctx.fillText(xlabel, this.width + this.x_padding + 15/2, this.y_max + this.y_padding - 10);\n    // ctx.fillText(ylabel, this.x_min + 15 + 15/2, this.y_padding - 20 );\n\n  }\n\n  generatePoints(fx, n = 100) {\n    const { vScale } = this;\n    const scaledWidth = this.width/this.scale;\n    const k = scaledWidth/vScale.width/n;\n    let f = () => {};\n\n    const Points = new Array();\n\n    try {\n      f = new Function('x', `with (Math) return ${fx}`);\n      f(0);\n    } catch(e) {\n      console.error('bad expression input');\n      return [];\n    }\n\n    const startX = -(Math.floor(this.offsetX/vScale.width) + 1);\n    const endX = Math.ceil((scaledWidth - this.offsetX)/vScale.width) + 1;\n\n    for (let i = startX; i <= endX; i += k) {\n      Points.push({ x: i, y: f(i) });\n    }\n\n    return Points;\n  }\n\n  centralizeCoord(x, y) {\n    this.offsetX = x + this.width/2/this.scale;\n    this.offsetY = y + this.height/2/this.scale;\n    this.runCycle();\n  }\n\n  addFunction(func, opt = {}) {\n    opt.func = func;\n\n    const index = this.functions.push({ ...opt, func });\n\n    this.runCycle();\n\n    return this.functions[index - 1];\n  }\n\n  drawFunctions(n) {\n    this.functions.forEach(({ func, ...opt }) => this.drawPoints(this.generatePoints(func, opt.amountPoints), opt));\n  }\n\n  drawPoints(data, custom) {\n    let opts = {\n      color: '#0000ff',\n      point: true,\n      line: true,\n      pointSize: 1,\n      lineWidth: 1,\n      pointColor: 'black',\n      lineColor: 'black',\n      fill: true,\n    };\n\n    Object.assign(opts, custom);\n    \n    const { ctx, origin, vScale: { vWidth, vHeight } } = this;\n    const xScale = this.vScale.width/vWidth;\n    const yScale = this.vScale.height/vHeight;\n\n    ctx.save();\n\n    const drawPoint = (x, y, radius) => {\n      ctx.beginPath();\n      ctx.arc(x * xScale, -y * yScale, radius/this.scale, 0, 2 * Math.PI, true);\n      opts.fill ? ctx.fill() : ctx.stroke();\n    };\n\n    if (opts.line) {\n      ctx.beginPath();\n      ctx.strokeStyle = opts.lineColor;\n      data.forEach(({ x, y }) => ctx.lineTo(x * xScale,  -y * yScale));\n      ctx.lineWidth = opts.lineWidth;\n      ctx.stroke();\n    }\n\n    if (opts.point) {\n      ctx.strokeStyle = ctx.fillStyle = opts.pointColor;\n      data.forEach(({ x, y }) => drawPoint(x, y, opts.pointSize));\n    }\n\n    ctx.restore();\n  }\n\n  runCycle() {\n    const { ctx, vScale } = this;\n    this.clearCanvas();\n    ctx.save();\n    ctx.scale(this.scale, this.scale);\n    ctx.translate(this.offsetX, this.offsetY);\n    this.drawGrid('lightgray', vScale.width, vScale.height);\n    this.drawAxes();\n\n    this.drawFunctions(100);\n\n    ctx.restore();\n  }\n\n  normalizeX(x) {\n    return (x - this.offsetX)/this.scale;\n  }\n\n  normalizeY(y) {\n    return (y - this.offsetY)/this.scale;\n  }\n\n  round(number) {\n    return +(Math.round(number * 2) / 2).toFixed(1)\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./Plotter.js\n **/"],"sourceRoot":""}